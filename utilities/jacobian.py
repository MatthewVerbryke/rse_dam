#!/usr/bin/env python

"""
  Jacobian solution generator that  for a dual-arm robot.

  Copyright 2020 University of Cincinnati
  All rights reserved. See LICENSE file at:
  https://github.com/MatthewVerbryke/rse_dam
  Additional copyright may be held by others, as reflected in the commit
  history.

  NOTE: Hoping that having a pre-generated solution in numpy might be 
        faster than manipulating sympy symbols directly.

  TODO: Need to check accuracy of current code's answer
  
"""


import csv
import os
import string
import sys
import tkFileDialog
import traceback

import numpy as np
import sympy as sp
from sympy import sin, cos
from sympy.matrices import Matrix, eye, zeros


def get_jacobian_function(DH_param):
    """
    Create the required functions to get the Jacobian based on the DH 
    parameters of the arm.
    
    NOTE: DH parameterization based on that found in John J. Craig's 
          "Introduction to Robotics, Mechanics and Control" 3rd edition
    """
    
    # Basic information
    num_joints = len(DH_param)
    J_func = zeros(6,num_joints)
    offsets = [None]*num_joints
    var_list = sp.symbols('q0:{}'.format(num_joints))
        
    # Storage
    T_i = [None]*num_joints
        
    # Get DH parameters for each link
    for i in range(0,num_joints):
        alpha = sp.sympify(DH_param[i][0])
        a = sp.sympify(DH_param[i][1])
        d = sp.sympify(DH_param[i][2])
        theta = var_list[i]# + sp.sympify(DH_param[i][3])
        
        # Determine individual link transformation matrices
        T = Matrix([[cos(theta), -sin(theta), 0, a],
                    [sin(theta)*cos(alpha), cos(theta)*cos(alpha), -sin(alpha), -sin(alpha)*d],
                    [sin(theta)*sin(alpha), cos(theta)*sin(alpha), cos(alpha), cos(alpha)*d],
                    [0, 0, 0, 1]])
        
        # Multiply this transformation to get the transformation to the ith joint
        if i == 0:
            T_i[0] = eye(4)*T
        else:
            T_i[i] = T_i[i-1]*T
        
    # Get the end effector transformation
    T_eef = T_i[num_joints-1]
    
    # Get out position functions from final transformation matrix
    p_eef = [T_eef[0,3], T_eef[1,3], T_eef[2,3]]
        
    # Get Jacobian component equations
    for i in range(0,num_joints):
            
        # Determine derivatives for linear Jacobian component
        for j in range(0,3):
            J_func[i, j] = sp.diff(p_eef[j], var_list[i])
                
        # Determine the rotational Jacobian components
        R_0i = T_i[i][0:3,0:3]
        w_0i = R_0i*Matrix([[0],[0],[1]])
        for k in range(0,3):
            J_func[i, k+3] = w_0i[k]
            
    return J_func

def format_solution(J_func):
    """
    Create and format the Jacobian function as a string for writing to 
    file.
    """
    
    # Basic information
    num_row, num_col = J_func.shape
    var_list = [None]*num_col
    tab = '    '
    
    # Recreate list of variable names (as strings)
    n = 0
    while (n < num_col):
        var_list[n] = 'q{}'.format(n)
        n += 1
    
    # Front matter
    write_list = ['#!/usr/bin/env python\n',
                  '\n',
                  '"""\n',
                  '  Autogenerated function to determine the Jacobian matrix for a serial arm.\n'
                  '"""\n',
                  '\n',
                  'from math import cos, sin, pi\n',
                  '\n'
                  'import numpy as np\n',
                  '\n',
                  '\n']
                
    # Function declaration
    write_list.append('def solve_jacobian(q):\n')
    write_list.append(tab + '\n')
    
    # Input Parsing
    for k in range(0,num_col):
        parse_str = 'q{} = q[{}]'.format(k, k)
        write_list.append(tab + parse_str + '\n')
    
    # Generating empty matrix (np.array)
    write_list.append(tab + 'J = np.zeros(6, {})'.format(num_col) + '\n')
    
    # Solutions for each term in the Jacobian
    for i in range(0,num_col):
        for j in range(0,6):
            equation_str = 'J[{},{}] = '.format(j,i) + str(J_func[j,i])
            #for k in range(0,num_col):
                #var_list[k] in equation_str
                #if var_list[k] in equation_str:
                    #equation_str.replace(var_list[k], 'q[{}]'.format(k))
            write_list.append(tab + equation_str + '\n')
            
    # return for the Jacobian
    write_list.append(tab + '\n')
    write_list.append(tab + 'return J\n')
    
    return write_list
    
def main():
    """
    Main execution script.
    """
    
    # Get relevent directories
    home_dir = os.getcwd()
    os.chdir('../..')
    src_dir = os.getcwd()
    os.chdir(home_dir)
    
    # As for the csv file containing the DH parameters of the arm
    DH_file = tkFileDialog.askopenfilename(initialdir=src_dir,
                                           title='Select File',
                                           filetypes=(('csv files','*.csv'),))
                                           
    # Open and read the contents
    DH_params = []
    with open(DH_file, 'rb') as csvfile:
        csv_reader = csv.reader(csvfile)
        for row in csv_reader:
            DH_params.append(row)
            
    # Determine the Jacobian functions
    J = get_jacobian_function(DH_params)
    write_list = format_solution(J)
    
    # Ask where to put the jacobian function
    J_dir = tkFileDialog.askdirectory()
    
    try:
        
        # Go to this directory
        os.chdir(J_dir)
    
        # Write function to file 
        with open('jacobian.py', 'w') as target:
            for item in write_list:
                target.write(item)
                
    finally:
        
        # Set directory back to home
        os.chdir(home_dir)


if __name__ == "__main__":
    try:
        main()
    except Exception:
        traceback.print_exc()
