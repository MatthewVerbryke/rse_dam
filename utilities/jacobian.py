#!/usr/bin/env python

"""
  Jacobian solution generator for a dual-arm robot.

  Copyright 2020 University of Cincinnati
  All rights reserved. See LICENSE file at:
  https://github.com/MatthewVerbryke/rse_dam
  Additional copyright may be held by others, as reflected in the commit
  history.

  NOTE: Hoping that having a pre-generated solution in numpy might be 
        faster than manipulating sympy symbols directly.

  WARN: Probably will need to be reworked as some issues have cropped up
        with in the code
  
"""


import os
import string
import sys
import tkFileDialog
import traceback

from geometry_msgs.msg import Pose
import numpy as np
import sympy as sp
from sympy import sin, cos
from sympy.matrices import Matrix, eye, zeros
from tf import transformations
import yaml



def get_jacobian_function(DH_param, base_transform):
    """
    Create the required functions to get the Jacobian based on the DH 
    parameters of the arm.
    
    NOTE: DH parameterization based on that found in John J. Craig's 
          "Introduction to Robotics, Mechanics and Control" 3rd edition
    """
    
    # Basic information
    num_joints = len(DH_param)
    J_func = zeros(num_joints, 6)
    offsets = [None]*num_joints
    var_list = sp.symbols('q0:{}'.format(num_joints))
        
    # Storage
    T_i = [None]*num_joints
        
    # Get DH parameters for each link
    for i in range(0,num_joints):
        alpha = sp.sympify(DH_param[i][0])
        a = sp.sympify(DH_param[i][1])
        d = sp.sympify(DH_param[i][2])
        theta = var_list[i]# + sp.sympify(DH_param[i][3])
        
        # Determine individual link transformation matrices
        T = Matrix([[cos(theta), -sin(theta), 0, a],
                    [sin(theta)*cos(alpha), cos(theta)*cos(alpha), -sin(alpha), -sin(alpha)*d],
                    [sin(theta)*sin(alpha), cos(theta)*sin(alpha), cos(alpha), cos(alpha)*d],
                    [0, 0, 0, 1]])
        
        # Multiply this transformation to get the transformation to the ith joint
        if i == 0:
            T_i[0] = base_transform*T
        else:
            T_i[i] = T_i[i-1]*T
        
    # Get the end effector transformation
    T_eef = T_i[num_joints-1]
    
    # Get out position functions from final transformation matrix
    p_eef = [T_eef[0,3], T_eef[1,3], T_eef[2,3]]
        
    # Get Jacobian component equations
    for i in range(0,num_joints):
            
        # Determine derivatives for linear Jacobian component
        for j in range(0,3):
            J_func[i, j] = sp.diff(p_eef[j], var_list[i])
                
        # Determine the rotational Jacobian components
        R_0i = T_i[i][0:3,0:3]
        w_0i = R_0i*Matrix([[0],[0],[1]])
        for k in range(0,3):
            J_func[i, k+3] = w_0i[k]
            
    return J_func.T

def format_solution(J_func):
    """
    Create and format the Jacobian function as a string for writing to 
    file.
    """
    
    # Basic information
    num_row, num_col = J_func.shape
    var_list = [None]*num_col
    tab = '    '
    
    # Recreate list of variable names (as strings)
    n = 0
    while (n < num_col):
        var_list[n] = 'q{}'.format(n)
        n += 1
    
    # Front matter
    write_list = ['#!/usr/bin/env python\n',
                  '\n',
                  '"""\n',
                  '  Autogenerated function to determine the Jacobian matrix for a serial arm.\n'
                  '"""\n',
                  '\n',
                  '\n',
                  'from math import cos, sin, pi\n',
                  '\n'
                  'import numpy as np\n',
                  '\n',
                  '\n']
                
    # Function declaration
    write_list.append('def solve_jacobian(q):\n')
    write_list.append(tab + '\n')
    
    # Input Parsing
    for k in range(0,num_col):
        parse_str = 'q{} = q[{}]'.format(k, k)
        write_list.append(tab + parse_str + '\n')
    
    # Generating empty matrix (np.array)
    write_list.append(tab + 'J = np.zeros((6, {}))'.format(num_col) + '\n')
    
    # Solutions for each term in the Jacobian
    for i in range(0,num_col):
        for j in range(0,6):
            equation_str = 'J[{},{}] = '.format(j,i) + str(J_func[j,i])
            #for k in range(0,num_col):
                #var_list[k] in equation_str
                #if var_list[k] in equation_str:
                    #equation_str.replace(var_list[k], 'q[{}]'.format(k))
            write_list.append(tab + equation_str + '\n')
            
    # return for the Jacobian
    write_list.append(tab + '\n')
    write_list.append(tab + 'return J\n')
    
    return write_list
    
def pose_to_transformation_matrix(pose):
    """
    Convert a 'geometry_msgs/Pose' representation into a homogeneous
    transformation matrix.
    
    TODO: move to a common area for reusability
    """
    
    # Get pose as column vector
    p = np.array([[pose.position.x],
                  [pose.position.y],
                  [pose.position.z]])
                  
    # Get rotation matrix from quaternion
    q = [pose.orientation.x,
         pose.orientation.y,
         pose.orientation.z,
         pose.orientation.w]
    T = transformations.quaternion_matrix(q)
    
    # Place pose element into transformation matrix
    T[0:3,3:4] = p
    
    return T
    
def main():
    """
    Main execution script.
    """
    
    # Get relevent directories
    home_dir = os.getcwd()
    os.chdir('../..')
    src_dir = os.getcwd()
    os.chdir(home_dir)
    
    # As for the csv file containing the DH parameters of the arm
    DH_file = tkFileDialog.askopenfilename(initialdir=src_dir,
                                           title='Select DH Parameter File',
                                           filetypes=(('yaml files','*.yaml'),))
                                           
    # Open and read the contents
    with open(DH_file, 'rb') as yamlfile:
        content = yaml.load(yamlfile, Loader=yaml.FullLoader)
        
    # Put relevant data into correct formats
    DH_params = content["DH"]
    
    base_pose = []
    base_pose_content = content["left_arm_base_pose"] #<-- TODO: make more general
    base_pose = Pose()
    base_pose.position.x = base_pose_content[0]
    base_pose.position.y = base_pose_content[1]
    base_pose.position.z = base_pose_content[2]
    base_pose.orientation.x = base_pose_content[3]
    base_pose.orientation.y = base_pose_content[4]
    base_pose.orientation.z = base_pose_content[5]
    base_pose.orientation.w = base_pose_content[6]  
            
    # Determine the Jacobian functions
    base_T = pose_to_transformation_matrix(base_pose)
    J = get_jacobian_function(DH_params, base_T)
    write_list = format_solution(J)
    
    # Ask where to put the jacobian function
    J_dir = tkFileDialog.askdirectory()
    
    try:
        
        # Go to this directory
        os.chdir(J_dir)
    
        # Write function to file 
        with open('jacobian.py', 'w') as target:
            for item in write_list:
                target.write(item)
                
    finally:
        
        # Set directory back to home
        os.chdir(home_dir)


if __name__ == "__main__":
    try:
        main()
    except Exception:
        traceback.print_exc()
